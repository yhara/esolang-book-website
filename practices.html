<!DOCTYPE html><html><head><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><title>Rubyで作る奇妙なプログラミング言語</title><link href="stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" /><script src="javascripts/all.js" type="text/javascript"></script></head><body class="practices"><h1><a href="/">Rubyで作る奇妙なプログラミング言語</a></h1><div class="menu" id="ul"><li><a href="/eratta.html">正誤表</a></li><li><a href="/practices.html">練習問題の解答例</a></li><li><a href="/sources.html">ソースコード</a></li></div><h2>練習問題の解答例</h2>

<p>各章末の練習問題の解答例です。</p>

<h3>1-1</h3>

<h4>Q1</h4>

<p>回答例はこちら。</p>

<pre><code>puts&quot;Hello, world!&quot;
</code></pre>

<p>以上で19バイト。現在のRubyの文法では、これが最短だろう。
(「ファイルに保存したら20バイトになったよ」という人は、末尾に余計な改行が付いているものと思われる。)</p>

<p>別解として、</p>

<pre><code>$&gt;&lt;&lt;&quot;Hello, world!&quot;
</code></pre>

<p>というのもある。</p>

<p>「$&gt;」は「$stdout」という組み込み変数の別名で、標準出力を表すIOオブジェクトだ。なので、「$&gt; &lt;&lt; &quot;Hello, world!&quot;」とするとIOクラスのインスタンスメソッド「&lt;&lt;」が呼び出され、「Hello, world!」という文字列が標準出力に出力されるというわけだ(細かいことを言うと、putsだと最後に改行が出力されるが、&lt;&lt;だと改行が出力されないという違いがある)。</p>

<h4>Q2</h4>

<p>解答例はこちら(281バイト)。あなたはこれよりも短くできただろうか？:-)</p>

<pre><code>b=proc{|n,w|&quot;#{n==0?&#39;no more&#39;:n} bottle#{&#39;s&#39;unless n==1} of beer#{&#39; on the wall&#39;if w}&quot;}
puts [&quot;#{b[99,1]}, #{b[99,p]}.&quot;,(0..98).map{|n|[&quot;Take one down and pass it around, #{b[n,1]}.&quot;,&quot;&quot;,&quot;#{b[n,1].capitalize}, #{b[n,p]}.&quot;]}.reverse, &quot;Go to the store and buy some more, #{b[99,1]}.&quot;]
</code></pre>

<p>あるプログラムをできるだけ少ないバイト数で書くという遊びは、一般に
「ショートコーディング」や「コードゴルフ」という名前で知られている。
1バイトでも短いコードを書いた人が勝ちというルールを、
少ない打数でゴール地点を目指すゴルフ競技になぞらえたわけだ。</p>

<p>ゴルフに興味を持った方は、「<a href="http://codegolf.com/">Code Golf</a>」や「<a href="http://golf.shinh.org/">anarchy golf</a>」
といったサイトに挑戦してみるといいだろう。
また、Rubyに関する記事を集めたWeb雑誌、「<a href="http://jp.rubyist.net/magazine/">Rubyist Magazine</a>」(通称るびま)でも<a href="http://jp.rubyist.net/magazine/?0021-RubiMaGolf">ゴルフについての記事</a>が掲載されている。</p>

<h4>Q3</h4>

<p>回答例はこちら。</p>

<pre><code>puts format(x=&quot;puts format(x=%p, x)&quot;, x)
</code></pre>

<p>一見何がどうなっているのか分からないと思うが、実際に実行して結果を確かめてほしい。「&quot;」を出力するためにformatメソッドの「%p」というパターンを使っているのがポイントだ。%pを使うと、引数(この場合ならxだ)のinspectメソッドを呼んだ結果がその場所に埋め込まれる。</p>

<p>ちなみにformatと同じことを行うString#%という関数もある。
こちらを使うともう少し短くできる。</p>

<pre><code>puts (x=&quot;puts (x=%p) %% x&quot;) % x
</code></pre>

<p>最後の「% x」を出力するために、文字列中では「%% x」と「%」を2つ書かないといけないことに注意。formatやString#%に渡す文字列の中では「%」は特殊な意味を持つので、「%」自身を出力するときは「%%」と書かなくてはならない。</p>

<h3>1-2</h3>

<p>回答例を以下に示す。オリジナルのHQ9+インタプリタと同じ点は省略してある。</p>

<pre><code>require &#39;counter&#39;
require &#39;rubygems&#39;
require &#39;sl&#39;

class HSQ9Plus
  # (略)

  def run
    @src.each_char do |c|
      case c
      when &quot;H&quot;
        hello
      when &quot;S&quot;
        run_sl
      when &quot;Q&quot;
        print_source
      when &quot;9&quot;
        print_99_bottles_of_beer
      when &quot;+&quot;
        increment
      end
    end
  end

  private

  # (略)

  def run_sl
    SL.run!
  end

  # (略)
end

HSQ9Plus.new(ARGF.read).run
</code></pre>

<p>筆者が考えたHSQ9+言語では、S命令を実行すると画面にSLが走る。</p>

<p><img alt="sl" src="images/sl.png" /></p>

<p>ソースコードの全体は以下からダウンロードできる。</p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/hsq9plus.rb">hsq9plus.rb</a></li>
</ul>

<p>SLを走らせるために、<a href="https://github.com/cesare/pebbles-sl">pebbles-sl</a>というライブラリが必要だ。以下のようにしてインストールしてほしい。</p>

<pre><code>$ gem install pebbles-sl
</code></pre>

<h3>1-3</h3>

<p>回答例は以下。</p>

<pre><code>Brainf*ckの各命令を、以下のように置き換える。
&gt; : else
&lt; : while 
+ : if 
- : do
. : until
, : for
[ : then
] : end
</code></pre>

<p>すると、1-3で出てきた「Aという文字を出力するプログラム」は以下のようになる。</p>

<pre><code>if if if if if if
then else if if if if if if if if if if while do end
else if if if if if until
</code></pre>

<p>筆者はこの言語を「Uncontrollable」と名付けた。「The Uncontrollable programming language」である。</p>

<p>英語で「control structure」と言えば制御構造、つまりifやwhileなどプログラムの実行を制御するもののことを言う。しかし、この言語では見た目こそ「if」や「while」などの制御構造に使われる単語が並んでいるが、その意味は「数値を1増やす」だったり「ポインタを左に移動する」だったりして、さっぱり制御する気がない。そこで「Uncontrollable」というわけだ。</p>

<h4>実装</h4>

<p>実装は以下のようになる。</p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/uncontrollable.rb">uncontrollable.rb</a></li>
</ul>

<p>オリジナルのBrainf*ckと違い、命令が文字単位ではないので、
ソースコードを命令に区切るのにString#charsではなくString#splitを使っているのが違いだ。</p>

<h3>1-4</h3>

<p>無限に「A」という文字を表示しつづけるWhitespaceプログラムは以下のようになる。 </p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/forever_a.ws">forever_a.ws</a></li>
</ul>

<p>分かりやすく書くと、こうだ。</p>

<pre><code>[LF][Space][Space][Space][LF]
[Space][Space][Space][Tab][Space][Space][Space][Space][Space][Tab][LF]
[Tab][LF][Space][Space]
[LF][Space][LF][Space][LF]
</code></pre>

<p>それぞれの行が、Ruby風にいうと以下のような命令に対応している。</p>

<pre><code>label &quot;s&quot;                                                                 
push 65                                                                 
char_out                                                                
jump &quot;s&quot;
</code></pre>

<p>label命令とjump命令が無限ループを実現していて、その間に挟まれた命令がループごとに実行される処理だ。
このWhitespaceプログラムは決して終わらないので、exit命令は使っていない。</p>

<h3>2-1</h3>

<h4>Q1</h4>

<p>回答例は以下。</p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/hello.sta">hello.sta</a></li>
</ul>

<pre><code>            +               +  *       +    
 * + .        +              +  *       +   
  *     * + .            +     * + . + .    
    +     * + .              +            + 
 *         +     * * + .                 + *
 + .              + +  *           +     *  
   * + .             + * + .        +     * 
+ .           + * + .             + * + .   
           +            +  *         +     *
 * + .
</code></pre>

<h4>Q2</h4>

<p>回答例は以下。</p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/fibs.sta">fibs.sta</a>
以下のような命令を使用している。</li>
</ul>

<pre><code>[:push, 0]   # 0
[:push, 1]   # 0 1
[:label, 1]              # ループの飛び先
  [:dup]       # 0 1 1
  [:rotate]    # 1 0 1
  [:+]         # 1 1
  [:dup]       # 1 1 1
  [:num_out]   # 1 1 
  [:push, 10]  # 1 1 10
  [:char_out]  # 1 1     # 改行が出力される
  [:dup]       # 1 1 1
[:jump, 1]   # 1 1
</code></pre>

<h4>Q3</h4>

<p>回答例は以下。</p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/fibn.sta">fibn.sta</a></li>
</ul>

<p>以下のような命令を使用している。</p>

<pre><code>[:push, 0],   # 0
[:push, 1],   # 0 1
[:num_in],    # ユーザが「10」を入力したとすると
              # 0 1 10
[:label, 1],
  [:rotate],    # 10 0 1
  [:dup],       # 10 0 1 1
  [:rotate],    # 10 1 0 1
  [:+],         # 10 1 1
  [:dup],       # 10 1 1 1
  [:num_out],   # 10 1 1
  [:push, 10],
  [:char_out],
  [:rotate],    # 1 10 1
  [:rotate],    # 1 1 10
  [:push, 1],   # 1 1 10 1
  [:-],         # 1 1 9
  [:dup],       # 1 1 9 9
[:jump, 1]      # 1 1 9
</code></pre>

<h3>2-2</h3>

<p>FizzBuzzプログラムを書くには、割り算の余りをとる操作が必要だ。というわけで、これを命令として追加してしまうのが簡単だろう。</p>

<p>「%」で割り算の余りを計算できるRubyに倣って、筆者は全角の「％」にこの操作を割り当てることにした。
優先度もRubyの「%」を真似て、かけ算や割り算と同じにすることにした。</p>

<p>％命令を実装するには、以下の2箇所を書き換えればいい。</p>

<pre><code>*** bolic_intp.rb       2008-11-24 14:18:32.000000000 +0900
--- bolic_intp2.rb      2008-12-26 21:46:33.000000000 +0900
***************
*** 32,37 ****
--- 32,39 ----
          eval(tree[1]) * eval(tree[2])
        when :/
          eval(tree[1]) / eval(tree[2])
+       when :%
+         eval(tree[1]) % eval(tree[2])
        when :char_out
          print eval(tree[1]).chr
          nil
***************
*** 188,193 ****
--- 190,197 ----
          [:*, left, parse_multiple]
        elsif match?(&quot;÷&quot;)
          [:/, left, parse_multiple]
+       elsif match?(&quot;％&quot;)
+         [:%, left, parse_multiple]
        else
          left
        end
</code></pre>

<p>こうすると、以下のようなFizzBuzzプログラムを実行できるようになる。</p>

<ul>
<li><a href="https://github.com/yhara/esolang-book-sources/blob/master/_practices/fizzbuzz.bol">fizzbuzz.bol</a></li>
</ul>

<h4>100までのループを書く方法</h4>

<p>Bolicにはwhile命令があるので、1から100まで繰り返すには、まず1が代入された変数を用意し、
ループを実行するごとにそれを1だけ増やして、101になったらループを抜ければいい。</p>

<p>ループを抜ける条件を思いだそう。Bolicのwhileループは、数値が0以外のとき処理を実行し、数値が0ならループを抜けるのだった。
ということは、「変数から101を引いた結果」をループの条件にすれば、
変数が101になったときにうまくループを抜けることができる。</p>

<h4>条件を否定する方法</h4>

<p>BoilcにはRubyでいう「not」がない。</p>

<p>これを命令として追加してもいいが(与えられた数が0なら1を、0以外なら0を返す命令になるだろう)、
Bolicのif命令をうまく使うと、指定した条件が「成り立たなかったときだけ」ある処理を行うことができる。
つまり、if-then-elseのthen節に何も書かず、else節にだけ処理を書いておくのだ。</p>

<h4>余談</h4>

<p>設問では「1つ以上の命令を追加し…」としか書いていないため、％命令に限らず、</p>

<ul>
<li>実行すると「Fizz」という文字列を表示する命令</li>
<li>整数が負かどうかを判定する命令</li>
<li>実行すると指定した数までのFizzBuzzプログラムを実行する命令(!)</li>
</ul>

<p>など、いろいろな方法が考えられるだろう。Bolicはあなたの言語なのだから、どんな命令を追加するのも、あなたの思いのままだ。</p>

<h3>EX</h3>

<p>以下は筆者の作成したEsoteric Languageである。</p>

<h4>ModanShogi (2010)</h4>

<ul>
<li><a href="http://gihyo.jp/dev/column/01/prog/2010/aprilfool2010-01">将棋をモチーフにしたプログラミング言語「ModanShogi」が公開！｜gihyo.jp … 技術評論社</a></li>
<li><a href="https://github.com/yhara/ShogiModan">https://github.com/yhara/ShogiModan</a></li>
</ul>

<h4>smile (2011)</h4>

<ul>
<li><a href="https://github.com/yhara/smile">https://github.com/yhara/smile</a></li>
</ul>
</body></html>